exports.Validator = (function() {
	var crypto = require('crypto');
	var dcrypt = require('dcrypt');
	var Expat2 = require('expat2');
	var EventEmitter = require('events').EventEmitter;
	var util = require('util');

	var SIG_NS                        = 'http://www.w3.org/2000/09/xmldsig#';
	var SIG_PROPERTY_NS               = 'http://www.w3.org/2009/xmldsig-properties';

	var SIG_ALGORITHM_RSAwithSHA256   = 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256';
	var SIG_ALGORITHM_DSAwithSHA1     = 'http://www.w3.org/2000/09/xmldsig#dsa-sha1';
	var SIG_ALGORITHM_ECDSAwithSHA256 = 'http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256';
	var DIGEST_ALGORITHM_SHA256       = 'http://www.w3.org/2001/04/xmlenc#sha256';

	var C14N_ALGORITHM_XMLEXC         = 'http://www.w3.org/2001/10/xml-exc-c14n#';
	var C14N_ALGORITHM_XMLEXCCOMM     = 'http://www.w3.org/2001/10/xml-exc-c14n#WithComments';
	var C14N_ALGORITHM_XML10          = 'http://www.w3.org/2006/12/xml-c14n10';
	var C14N_ALGORITHM_XML11          = 'http://www.w3.org/2006/12/xml-c14n11';
	var C14N_ALGORITHM_XML11COMM      = 'http://www.w3.org/2006/12/xml-c14n11#WithComments';
	var C14N_ALGORITHM_XML            = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315';
	var C14N_ALGORITHM_XMLCOMM        = 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments';

	var C14N_ALGORITHMS = {};
	C14N_ALGORITHMS[C14N_ALGORITHM_XMLEXC]        = false;
	C14N_ALGORITHMS[C14N_ALGORITHM_XMLEXCCOMM]    = false;
	C14N_ALGORITHMS[C14N_ALGORITHM_XML10]         = false;
	C14N_ALGORITHMS[C14N_ALGORITHM_XML]           = true;
	C14N_ALGORITHMS[C14N_ALGORITHM_XMLCOMM]       = false;
	C14N_ALGORITHMS[C14N_ALGORITHM_XML11]         = true;
	C14N_ALGORITHMS[C14N_ALGORITHM_XML11COMM]     = false;

	var TRANSFORMS = C14N_ALGORITHMS;

	var SIG_ALGORITHMS = {};
	SIG_ALGORITHMS[SIG_ALGORITHM_ECDSAwithSHA256] = false;
	SIG_ALGORITHMS[SIG_ALGORITHM_RSAwithSHA256]   = true;
	SIG_ALGORITHMS[SIG_ALGORITHM_DSAwithSHA1]     = true;

	/* public constructor */
	function Validator() {
		EventEmitter.call(this);
		this.parser = new Expat2.Parser('UTF-8');

		/* map of reference objects, indexed
		 * by refUri */
		this.references = {};

		/* map of signature properties, indexed
		 * by propertyUri */
		this.properties = {};
		
		/* map of Object elements, indexed
		 * by Id */
		this.objectElements = {};

		/* the id of the signature properties
		 * ds:Object */
		this.signaturePropertiesId = undefined;

		/* array of x509 certificate objects */
		this.certificates = [];

		/* array of x509 CRL objects */
		this.crls = [];
	}
	util.inherits(Validator, EventEmitter);

	/* public instance methods */
	Validator.prototype.parse = function(sigBuffer) {
		var that = this;
		
		/* check there is no BOM */
		if(sigBuffer[0] + sigBuffer[1] == 0xfe + 0xff) {
			this.emit('error', new Error('Invalid encoding (BOM present)'));
			return;
		}

		/********************
		 * Signature state
		 ********************/

		var SignatureMethod;
		var CanonicalizationMethod;
		var SignatureValue;

		/* single-element types */
		var propertiesElement;
		var signedInfoElement;
		var keyInfoElement;
		var objectElements = this.objectElements;
		var references = this.references;

		var xmlDecl = function(version, encoding, standalone) { 
			if(encoding && encoding != 'UTF-8')
				this.emit('error', new Error('Invalid encoding: ' + encoding));
		};

		var startDocument = function(elt) {
			var isSig = elt.isSig = (elt.nsUri == SIG_NS);
			var name = elt.name;
			var attrs = elt.attrs;
			/*
			 * ASSERTION # root-signature
			 * If the root element is not a signature element in the xml digsig namespace,
			 * then the user agent MUST terminate this algorithm and treat this
			 * signature as being in error.
			 */
			if(name != 'Signature' || !isSig) {
				that.emit('error', new Error('root-signature'));
				return;
			}
			elt.isValid = true;

			/* do signature attrs */
			if('Id' in attrs) {
				that.Id = attrs.Id;
			}
		};

		var startElement = function(elt) {
			var isSig = elt.isSig = (elt.nsUri == SIG_NS);
			var isSigProperties = elt.isSigProperties = (elt.nsUri == SIG_PROPERTY_NS);
			var eltName = elt.nsName;
			var attrs = elt.attrs;
			var parent = elt.parent;

			if(isSig && eltName == 'SignedInfo') {
				if(signedInfoElement) {
					that.emit('error', new Error('duplicate SignedInfo element'));
					return;
				}
				if(!parent.isRoot) {
					that.emit('error', new Error('misplaced SignedInfo element'));
					return;
				}
				signedInfoElement = elt;
				elt.isValid = true;

			} else if(isSig && eltName == 'SignatureMethod') {
				if(SignatureMethod) {
					that.emit('error', new Error('duplicate SignatureMethod'));
					return;
				}
				if(signedInfoElement != parent) {
					that.emit('error', new Error('misplaced SignatureMethod'));
					return;
				}
				if(!('Algorithm' in attrs)) {
					that.emit('error', new Error('SignatureMethod has no Algorithm'));
					return;
				}
				SignatureMethod = attrs.Algorithm;
				if(!(SignatureMethod in SIG_ALGORITHMS)) {
					that.emit('error', new Error('SignatureMethod has invalid Algorithm: ' + signatureMethod));
					return;
				}
				if(!SIG_ALGORITHMS[SignatureMethod]) {
					that.emit('unsupported', new Error('SignatureMethod has an unsupported Algorithm: ' + signatureMethod));
					return;
				}
				that.SignatureMethod = SignatureMethod;
				elt.isValid = true;

			} else if(isSig && eltName == 'CanonicalizationMethod') {
				if(CanonicalizationMethod) {
					that.emit('error', new Error('duplicate CanonicalizationMethod'));
					return;
				}
				if(signedInfoElement != parent) {
					that.emit('error', new Error('misplaced CanonicalizationMethod'));
					return;
				}
				if(!('Algorithm' in attrs)) {
					that.emit('error', new Error('CanonicalizationMethod has no Algorithm'));
					return;
				}
				CanonicalizationMethod = attrs.Algorithm;
				if(!(CanonicalizationMethod in C14N_ALGORITHMS)) {
					that.emit('error', new Error('CanonicalizationMethod has an invalid Algorithm: ' + CanonicalizationMethod));
					return;
				}
				if(!C14N_ALGORITHMS[CanonicalizationMethod]) {
					that.emit('unsupported', new Error('CanonicalizationMethod has an unsupported Algorithm: ' + CanonicalizationMethod));
					return;
				}
				that.CanonicalizationMethod = CanonicalizationMethod;
				elt.isValid = true;

			} else if(isSig && eltName == 'Reference') {
				if(signedInfoElement != parent) {
					that.emit('error', new Error('misplaced Reference'));
					return;
				}
				if(!('URI' in attrs)) {
					that.emit('error', new Error('Reference has no URI'));
					return;
				}
				var refUri = attrs.URI;
				if(refUri in references) {
					that.emit('error', new Error('Reference with duplicate URI'));
					return;
				}
				references[refUri] = { URI: refUri, elt: elt };
				elt.isValid = true;

			} else if(isSig && eltName == 'DigestMethod') {
				if(!parent.isValid || parent.nsName != 'Reference') {
					that.emit('error', new Error('misplaced DigestMethod'));
					return;
				}
				var reference = references[parent.attrs.URI];
				if(reference.DigestMethod) {
					that.emit('error', new Error('duplicate DigestMethod'));
					return;
				}
				if(!('Algorithm' in attrs)) {
					that.emit('error', new Error('DigestMethod has no Algorithm'));
					return;
				}
				var DigestMethod = attrs.Algorithm;
				if(DigestMethod != DIGEST_ALGORITHM_SHA256) {
					that.emit('unsupported', new Error('DigestMethod has invalid or unsupported Algorithm: ' + DigestMethod));
					return;
				}
				reference.DigestMethod = DigestMethod;
				elt.isValid = true;

			} else if(isSig && eltName == 'Transforms') {
				if(!parent.isValid || parent.nsName != 'Reference') {
					that.emit('error', new Error('misplaced Transforms'));
					return;
				}
				elt.isValid = true;

			} else if(isSig && eltName == 'Transform') {
				if(!parent.isValid || parent.nsName != 'Transforms') {
					that.emit('error', new Error('misplaced Transform'));
					return;
				}
				var reference = references[parent.parent.attrs.URI];
				if(reference.Transform) {
					that.emit('error', new Error('duplicate Transform'));
					return;
				}
				if(!('Algorithm' in attrs)) {
					that.emit('error', new Error('Transform has no Algorithm'));
					return;
				}
				var Transform = attrs.Algorithm;
				if(!(Transform in TRANSFORMS)) {
					that.emit('error', new Error('Transform has invalid Algorithm: ' + Transform));
					return;
				}
				if(!TRANSFORMS[Transform]) {
					that.emit('unsupported', new Error('Transform has unsupported Algorithm: ' + Transform));
					return;
				}
				reference.Transform = Transform;
				elt.isValid = true;

			} else if(isSig && eltName == 'KeyInfo') {
				if(keyInfoElement) {
					that.emit('error', new Error('duplicate KeyInfo element'));
					return;
				}
				if(!parent.isRoot) {
					that.emit('error', new Error('misplaced KeyInfo element'));
					return;
				}
				keyInfoElement = elt;
				elt.isValid = true;

			} else if(isSig && eltName == 'X509Data') {
				if(parent != keyInfoElement) {
					that.emit('error', new Error('misplaced X509Data'));
					return;
				}
				elt.isValid = true;

			} else if(isSig && eltName == 'Object') {
				if(!parent.isRoot) {
					that.emit('error', new Error('misplaced Object'));
					return;
				}
				if(!('Id' in attrs)) {
					/* not an error, but it means this object is irrelevant */
					return;
				}
				var idStr = attrs.Id;
				if(!idStr) {
					/* not an error, but it means this object is irrelevant */
					return;
				}
				objectElements[idStr] = elt;
				elt.isValid = true;

			} else if(isSig && eltName == 'SignatureProperties') {
				if(!parent.isValid || parent.nsName != 'Object') {
					that.emit('error', new Error('misplaced SignatureProperties'));
					return;
				}
				if(propertiesElement) {
					that.emit('error', new Error('duplicate SignatureProperties element'));
					return;
				}
				propertiesElement = elt;
				that.signaturePropertiesId = parent.attrs.Id;
				elt.isValid = true;

			} else if(isSig && eltName == 'SignatureProperty') {
				if(parent != propertiesElement) {
					that.emit('error', new Error('misplaced SignatureProperty'));
					return;
				}
				if('Target' in attrs) {
					var Target = attrs.Target;
					if(Target != ('#' + that.Id)) {
						that.emit('error', new Error('SignatureProperty has invalid Target'));
						return;
					}
				}
				elt.isValid = true;

			} else if(isSigProperties && (eltName == 'Profile' || eltName == 'Role')) {
				if(!parent.isValid || parent.nsName != 'SignatureProperty') {
					that.emit('error', new Error('misplaced ' + eltName));
					return;
				}
				if(!('URI' in attrs)) {
					that.emit('error', new Error(eltName + ' has no URI'));
					return;
				}
				var uriAttr = attrs.URI;
				if(eltName in that.properties) {
					that.emit('error', new Error('duplicate SignatureProperty: URI = ' + uriAttr));
					return;
				}
				var property = { type: eltName, URI: uriAttr, elt: elt };
				if('Id' in parent.attrs) {
					property.Id = parent.attrs.Id;
				}
				if('Target' in parent.attrs) {
					property.Target = parent.attrs.Target;
				}
				that.properties[eltName] = property;
				elt.isValid = true;

			}
		};

		var endElement = function(elt) {
			var name = elt.nsName;
			var parent = elt.parent;
			var isSig = elt.isSig = (elt.nsUri == SIG_NS);
			var isSigProperties = elt.isSigProperties = (elt.nsUri == SIG_PROPERTY_NS);

			if(isSig && name == 'DigestValue') {
				if(!parent.isValid || parent.nsName != 'Reference') {
					that.emit('error', new Error('misplaced DigestValue'));
					return;
				}
				var reference = references[parent.attrs.URI];
				if(reference.DigestValue) {
					that.emit('error', new Error('duplicate DigestValue'));
					return;
				}
				if(!elt.text) {
					that.emit('error', new Error('DigestValue has no text content'));
					return;
				}
				reference.DigestValue = elt.text.replace(/\n/g, '');
				elt.isValid = true;

			} else if(isSig && name == 'SignatureValue') {
				if(SignatureValue) {
					that.emit('error', new Error('duplicate SignatureValue'));
					return;
				}
				if(!parent.isRoot) {
					that.emit('error', new Error('misplaced SignatureValue'));
					return;
				}
				if(!elt.text) {
					that.emit('error', new Error('SignatureValue has no text content'));
					return;
				}
				SignatureValue = that.SignatureValue = elt.text.replace(/\n/g, '');
				elt.isValid = true;

			} else if(isSig && name == 'X509Certificate') {
				if(!parent.isValid || parent.nsName != 'X509Data') {
					that.emit('error', new Error('misplaced X509Certificate'));
					return;
				}
				if(!elt.text) {
					that.emit('error', new Error('X509Certificate has no text content'));
					return;
				}
				var x509Cert;
				try {
					x509Cert = dcrypt.x509.parseCert(elt.text, 'base64');
					if(x509Cert) {
						that.certificates.push(x509Cert);
						elt.isValid = true;
						return;
					}
				} catch(e) {}
				that.emit('error', new Error('Unable to parse X509Certificate' + (e ? ': exception = ' + e : '')));

			} else if(isSig && name == 'X509CRL') {
				if(!parent.isValid || parent.nsName != 'X509Data') {
					that.emit('error', new Error('misplaced X509CRL'));
					return;
				}
				if(!elt.text) {
					that.emit('error', new Error('X509CRL has no text content'));
					return;
				}
				var x509CRL, errorStr;
				try {
					x509CRL = dcrypt.x509.parseCrl(elt.text, 'base64');
					if(x509CRL) {
						that.crls.push(x509CRL);
						elt.isValid = true;
						return;
					}
				} catch(e) {errorStr = e;}
				that.emit('error', new Error('Unable to parse X509CRL' + (errorStr ? ': exception = ' + errorStr : '')));

			} else if(isSigProperties && (name == 'Identifier' || name == 'Created' || name == 'Expires')) {
				if(!parent.isValid || parent.nsName != 'SignatureProperty') {
					that.emit('error', new Error('misplaced ' + name));
					return;
				}
				if(name in that.properties) {
					that.emit('error', new Error('duplicate SignatureProperty (' + name + ')'));
					return;
				}
				if(!elt.text) {
					that.emit('error', new Error('SignatureProperty (' + name + ') has no text content'));
					return;
				}
				var property = { type: name, text: elt.text.replace(/\n/g, ''), elt: elt };
				if('Id' in parent.attrs) {
					property.Id = parent.attrs.Id;
				}
				if('Target' in parent.attrs) {
					property.Target = parent.attrs.Target;
				}
				that.properties[name] = property;
				elt.isValid = true;

			} else if(isSig && name == 'SignedInfo') {
				that.signedInfoC14nText = elt.eltC14nText;
			}
		};

		var endDocument = function() {};

		var parser = this.parser;
		parser.on('xmlDecl', xmlDecl);
		parser.on('startDocument', startDocument);
		parser.on('startElement', startElement);
		parser.on('endElement', endElement);
		parser.on('endDocument', endDocument);

		parser.parse(sigBuffer, {isFinal:true, c14n:true});
	};

	Validator.prototype.validatePropertiesReference = function() {
		if(!this.signaturePropertiesId) {
			this.emit('error', new Error('validatePropertiesReference: unable to locate properties Object'));
			return;
		}

		return this.validateSameDocumentReference(this.signaturePropertiesId);
	};

	Validator.prototype.validateSameDocumentReference = function(Id) {
		if(!(Id in this.objectElements)) {
			this.emit('error', new Error('validateSameDocumentReference: unable to locate Object with Id ' + Id));
			return;
		}
		
		var ref = '#' + Id;
		if(!(ref in this.references)) {
			this.emit('error', new Error('validatePropertiesReference: unable to locate reference with Id ' + ref));
			return;
		}

		var reference = this.references[ref];
		if(!('Transform' in reference)) {
			this.emit('unsupported', new Error('validateSameDocumentReference: reference ' + reference.URI + ' without explicit Transform is unsupported'));
			return;
		}

		if(reference.Transform != C14N_ALGORITHM_XML11) {
			this.emit('unsupported', new Error('validateSameDocumentReference: reference ' + reference.URI + ' has unsupported Transform'));
			return;
		}

		var expectedDigestValue = checkReference(reference);
		var hash = crypto.createHash('sha256');
		hash.update(this.objectElements[Id].eltC14nText, 'utf8');
		var actualDigestValue = hash.digest('base64');
		return actualDigestValue == expectedDigestValue;
	};
	
	var chooseEntityCert = function(certificates) {
		if(certificates.length == 0)
			return;
		if(certificates.length == 1)
			return certificates[0];
		/* choose end-entity cert, based on being
		 * a cert that is not the issuer for any other
		 * cert present in the signature */
		for(var i in certificates) {
			var cert = certificates[i];
			var subject = cert.subject;
			var isIssuer = false;
			for(var j in certificates) {
				if(i == j) continue;
				if(certificates[j].issuer == subject) {
					isIssuer = true;
					break;
				}
			}
			if(!isIssuer)
				return cert;
		}
	};
	
	var findIssuerCert = function(certificates, cert) {
		for(var i in certificates) {
			if(certificates[i] == cert) continue;
			if(certificates[i].subject == cert.issuer)
				return certificates[i];
		}
	};
	
	Validator.prototype.getCertificatePath = function() {
		if(!this.certificatePath) {
			var entityCert = chooseEntityCert(this.certificates);
			if(!entityCert) return;
			var path = this.certificatePath = [entityCert];
			var current = entityCert;
			while(true) {
				var issuer = findIssuerCert(this.certificates, current);
				if(!issuer) break;
				path.push(current = issuer);
			}
			/* for(var i in path)
				console.log(i + ': ' + path[i].subject); */
		}
		return this.certificatePath;
	};

	Validator.prototype.validateSignature = function() {
		if(!this.SignatureValue) {
			this.emit('error', new Error('validateSignature: no SignatureValue'));
			return;
		}
		
		if(!this.getCertificatePath()) {
			this.emit('error', new Error('validateSignature: no certificate path'));
			return;
		}

		var verify;
		if(this.SignatureMethod == SIG_ALGORITHM_RSAwithSHA256) {
			verify = dcrypt.verify.createVerify('RSA-SHA256');
		} else if(this.SignatureMethod == SIG_ALGORITHM_DSAwithSHA1) {
			verify = dcrypt.verify.createVerify('DSA-SHA1');
		} else {
			this.emit('unsupported', new Error('validateSignature: unsupported SignatureMethod: ' + this.SignatureMethod));
			return;
		}
		verify.update(this.signedInfoC14nText, 'utf8');
		var result = verify.verify(this.certificatePath[0], this.SignatureValue, 'base64');
		return result;
	};
	
	var checkReference = function(reference) {
		if(!('DigestMethod' in reference)) {
			this.emit('error', new Error('checkReference: reference ' + reference.URI + ' has missing DigestMethod'));
			return;
		}

		if(reference.DigestMethod != DIGEST_ALGORITHM_SHA256) {
			this.emit('unsupported', new Error('checkReference: reference ' + reference.URI + ' has unsupported DigestMethod'));
			return;
		}

		if(!('DigestValue' in reference)) {
			this.emit('error', new Error('checkReference: reference ' + reference.URI + ' has missing DigestValue'));
			return;
		}
		
		return reference.DigestValue;

	};

	Validator.prototype.validateExternalReference = function(dereferencer, refUri) {
		var reference = this.references[refUri];
		var expectedDigestValue = checkReference(reference);
		var hash = crypto.createHash('sha256');
		dereferencer(refUri, hash);
		var actualDigestValue = hash.digest('base64');
		if(actualDigestValue != expectedDigestValue)
			this.emit('error', new Error('validateExternalReference: reference ' + reference.URI + ' has unexpected DigestValue'));
	};

	Validator.prototype.validateAllReferences = function(dereferencer, requiresPropertiesRef, requiredExternalRefs) {
		var seenPropertiesRef = false;
		for(var i in this.references)  {
			if(i[0] == '#') {
				var Id = i.substr(1);
				this.validateSameDocumentReference(Id);
				if(Id == this.signaturePropertiesId)
					seenPropertiesRef = true;
			} else {
				this.validateExternalReference(dereferencer, i);
			}
		}
		if(requiresPropertiesRef && !seenPropertiesRef) {
			this.emit('error', new Error('validateAllReferences: required properties reference missing'));
			return;
		}
		
		if(requiredExternalRefs) {
			for(var i in requiredExternalRefs) {
				var refUri = requiredExternalRefs[i];
				if(!(refUri in this.references)) {
					this.emit('error', new Error('validateAllReferences: required external reference ' + refUri + ' missing'));
					return;
				}
			}
		}
	};

	return Validator;
})();
