exports.Parser = (function() {
	var path = require('path');
	var url = require('url');
	var util = require('util');
	var EventEmitter = require('events').EventEmitter;
	var Expat = require('node-expat').Parser;
	
	var XML_NS = 'http://www.w3.org/XML/1998/namespace';
	
	var textEncoder = function(c) {
		switch(c) {
		case 13:  /* '\r' */
			c = '&#xD;'; break;
		case 38: /* '&' */
			c = '&amp;'; break;
		case 60: /* '<' */
			c = '&lt;'; break;
		case 62: /* '>' */
			c = '&gt;'; break;
		default:
			c = String.fromCharCode(c);
		}
		return c;
	};
	
	var attrEncoder = function(c) {
		switch(c) {
		case 9:  /* '\t' */
			c = '&#x9;'; break;
		case 10:  /* '\n' */
			c = '&#xA;'; break;
		case 13:  /* '\r' */
			c = '&#xD;'; break;
		case 34: /* '"' */
			c = '&quot;'; break;
		case 38: /* '&' */
			c = '&amp;'; break;
		case 60: /* '<' */
			c = '&lt;'; break;
		default:
			c = String.fromCharCode(c);
		}
		return c;
	};
	
	var encodeString = function(string, encoder) {
		var result = '';
		for(var i = 0; i < string.length; i++)
			result += encoder(string.charCodeAt(i));
		return result;
	};

	var elementC14nText = function(elt, axesText) {
		return '<' + elt.qName + axesText + '>' + elt.bodyC14nText + '</' + elt.qName + '>';
	};
	
	var elementContextC14nText = function(elt) { return elementC14nText(elt, elt.contextC14nText); };
	var elementLocalC14nText = function(elt) { return elementC14nText(elt, elt.localC14nText); };

	var attrC14nText = function(nsAttr) {
		return ' ' + nsAttr.qName + '="' + encodeString(nsAttr.value, attrEncoder) + '"';
	};
	
	var getSorter = function(sortKeys) {
		return function(a, b) {
			for(var i in sortKeys) {
				var sortKey = sortKeys[i];
				aq = a[sortKey]; bq = b[sortKey];
				var res = (bq < aq) - (aq < bq);
				if(res) return res;
			}
			return 0;
		};
	};
	
	var nsSorter = getSorter(['qName']);
	var attrSorter = getSorter(['nsUri', 'name']);
	
	var axisC14nText = function(axes, sorter, ownOnly) {
		var result = '';
		for(var i in axes) {
			var axis = axes[i];
			var toSort = valuesArray(axis, ownOnly);
			if(toSort && toSort.length) {
				toSort.sort(sorter);
				for(var j in toSort) {
					if (toSort.hasOwnProperty(j))
					result += attrC14nText(toSort[j]);
				}
			}
		}
		return result;
	};

	var valuesArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !ob.hasOwnProperty(prop)) continue;
			result.push(ob[prop]);
		}
		return result.length ? result : undefined;
	};

	/* public constructor */
	function Parser(encoding) {
		EventEmitter.call(this);
		this.parser = new Expat(encoding);
	}
	util.inherits(Parser, EventEmitter);

	/* public instance methods */
	Parser.prototype.parse = function(buffer, opts) {
		var parser = this.parser;
		this.opts = opts;
		var that = this;

		/********************
		 * Generic DOM state
		 ********************/

		/* a stack of elements (index 0 is deepest) with path to current element
		 * element = {
		 *   name:         full element name string, including namespace if present
		 *   attrs:        collection of attribute values, keyed on full attribute name string,
		 *                 including namespace if present
		 *   nsAttrs:      collection of attributes, keyed on full attribute name string
		 *                 with the form {ns:<ns identifier>,
		 *                                nsName: <attr name less ns>,
		 *                                value: <attribute value> }
		 *   nsDict:       collection of namespace uris, keyed on ns id
		 *   ns:           element ns identifier
		 *   nsName:       element name less ns
		 *   nsUri:        resolved namespace uri
		 *   defaultNs:    uri of default namespace
		 *   text:         text content, non-normalised or processed
		 *   unicode:      text content, non-normalised but processed with directional chars
		 *   isRoot:       is the root element
		 *   isValid:      boolean, is understood to be a valid member of the schema based on
		 *                 path and the number of occurrences of this element already seen
		 * }
		 */
		var elementStack = [];

		/* the current ns->uri mapping */
		var nsDict = {};
		
		/* inheritable attributes */
		var inheritableAttr = {};

		/* url objects for xml:base inheritance */
		var xmlBase, localBase;

		/* the current default namespace */
		var defaultNs = '';
		
		/* signifies whether or not a complete document has been processed */
		var documentStarted = false;
		var documentComplete = false;
		
		/* c14n text */
		var preDocumentC14nText = '';
		var documentC14nText = '';
		var postDocumentC14nText = '';
		
		var getNsUri = function(ns, useDefault) {
			if(!ns && useDefault) return defaultNs;
			if(ns in nsDict) return nsDict[ns].value;
			if(ns == 'xml') return XML_NS;
			return '';
		};

		var xmlDecl = function(version, encoding, standalone) { 
			/* console.log('xmlDecl: ' + version + ', ' + encoding + ', ' + standalone); */
			that.emit('xmlDecl', version, encoding, standalone);
		};

		var startElement = function(name, attrs) {
			/* console.log('startElement: ' + name + ', ' + attrs); */
			var hasDefaultNs = false;

			/* create new local mappings */
			nsDict = Object.create(nsDict);
			inheritableAttr = Object.create(inheritableAttr);
			var nsAttrs = Object.create(inheritableAttr);

			/* generic attr processing */
			for(var attr in attrs) {
				var attrVal = attrs[attr];
				if(attr == 'xmlns') {
					if(attrVal != defaultNs) {
						defaultNs = attrVal;
						hasDefaultNs = true;
					}
					continue;
				}
				if(attr == 'xml:lang' || attr == 'xml:space') {
					inheritableAttr[attr] = {ns:'xml', name: attr.substr(4), qName: attr, value: attrVal};
					continue;
				}
				if(attr == 'xml:base') {
					/* process and consume */
					if(!attrVal) continue;
					localBase = url.parse(attrVal);
					/* remove any fragment component */
					delete localBase.hash;
					/* normalise any path component */
					if(localBase.path)
						localBase.path = path.normalize(localBase.path);

					var isAbsolutePath = localBase.path && localBase.path[0] == '/';
					if(xmlBase && !isAbsolutePath) {
						/* local is relative, must join */
						xmlBase = url.resolve(xmlBase, localBase);
					} else {
						xmlBase = localBase;
					}
					inheritableAttr[attr] = {ns:'xml', name: 'base', qName: attr, value: url.format(xmlBase)};
					continue;
				}
				var attrName = attr, attrNs = '', idx;
				if((idx = attr.indexOf(':')) != -1) {
					attrNs = attr.substr(0, idx);
					attrName = attr.substr(idx + 1);
					if(attrNs == 'xmlns') {
						/* ignore redundant definitions of the xml namespace */
						if(attrName == 'xml' && attrVal == XML_NS)
							continue;
						/* ignore definitions redundant by inheritance */
						if(attrName in nsDict && nsDict[attrName].value == attrVal)
							continue;
						/* add to local dict */
						nsDict[attrName] = {qName: 'xmlns:' + attrName, value: attrVal};
						continue;
					}
				}
				/* add to local (non-inheritable) attrs */
				nsAttrs[attr] = {ns:attrNs, name: attrName, qName: attr, value: attrVal};
			}
			/* once all ns attrs processed, populate resolved nsUri for each attr */
			for(var attr in nsAttrs) {
				var nsAttr = nsAttrs[attr];
				nsAttr.nsUri = getNsUri(nsAttr.ns);
			}

			/* generic element processing */
			var eltName = name, eltNs, idx;
			if((idx = name.indexOf(':')) != -1) {
				eltNs = name.substr(0, idx);
				eltName = name.substr(idx + 1);
			}
			var eltNsUri = getNsUri(eltNs, true);
			var qName = eltNs ? (eltNs + ':' + eltName) : eltName;
			var isRoot = (elementStack.length == 0);
			var parent = elementStack[0];
			var defaultNsText = ' xmlns="' + defaultNs + '"';
			var localC14nText = (hasDefaultNs ? defaultNsText : '') + axisC14nText([nsDict], nsSorter, true) + axisC14nText([nsAttrs, inheritableAttr], attrSorter, true);
			var contextC14nText = (defaultNs ? defaultNsText : '') + axisC14nText([nsDict], nsSorter, false) + axisC14nText([nsAttrs], attrSorter, false);

			var elt = {
				parent:           parent,
				name:             name,
				attrs:            attrs,
				nsAttrs:          nsAttrs,
				nsDict:           nsDict,
				ns:               eltNs,
				nsName:           eltName,
				qName:            qName,
				nsUri:            eltNsUri,
				defaultNs:        defaultNs,
				isRoot:           isRoot,
				text:             '',
				localC14nText:    localC14nText,
				contextC14nText:  contextC14nText,
				bodyC14nText:     '',
				eltC14nText:      '',
				inheritableAttr:  inheritableAttr,
				xmlBase:          xmlBase,
				localBase:        localBase
			};

			elementStack.unshift(elt);

			if(isRoot) {
				documentStarted = true;
				that.emit('startDocument', elt);
			} else {
				that.emit('startElement', elt);
			}
		};

		var endElement = function(name) {
			/* console.log('endElement: ' + name); */
			var elt = elementStack.shift();
			if(name != elt.name) {
				that.emit('error', new Error('Element nesting mismatch'));
				return;
			}
			
			if(that.opts.c14n)
				elt.eltC14nText = elementContextC14nText(elt);

			if(elementStack.length == 0) {
				documentC14nText = elt.eltC14nText;
				that.emit('endDocument', elt);
				documentComplete = true;
				return;
			}
			that.emit('endElement', elt);

			var parent = elementStack[0];
			if(that.opts.c14n)
				parent.bodyC14nText += elementLocalC14nText(elt);

			nsDict = parent.nsDict;
			defaultNs = parent.defaultNs;
			inheritableAttr = parent.inheritableAttr;
			xmlBase = parent.xmlBase;
			localBase = parent.localBase;
		};

		var text = function(string) {
			/* console.log('text: ' + string); */
			var elt = elementStack[0];
			if(elt) {
				elt.text += string;
				if(that.opts.c14n)
					elt.bodyC14nText += encodeString(string, textEncoder);
			}
			that.emit('text', elt, string);
		};

		var processingInstruction = function(target, data) {
			/* console.log('processingInstruction: ' + target + ', ' + data); */
			if(that.opts.c14n) {
				var piText = '<?' + target;
				if(data) piText += ' ' + data;
				piText += '?>';
				if(!documentStarted)
					preDocumentC14nText += piText + '\n';
				else if(documentComplete)
					postDocumentC14nText += '\n' + piText;
				else
					elementStack[0].bodyC14nText += piText;
			}

			that.emit('processingInstruction', target, data);
		};

		var comment = function(string) {
			/* console.log('comment: ' + string); */
			if(that.opts.c14n && that.opts.c14nComments) {
				var commentText = '<!--' + string + '-->';
				if(!documentStarted)
					preDocumentC14nText += commentText + '\n';
				else if(documentComplete)
					postDocumentC14nText += '\n' + commentText;
				else
					elementStack[0].bodyC14nText += commentText;
			}
				
			that.emit('comment', string);
		};

		var startCdata = function() {
			/* console.log('startCdata'); */
			that.emit('startCdata', elementStack[0]);
		};

		var endCdata = function() {
			/* console.log('endCdata'); */
			that.emit('endCdata', elementStack[0]);
		};

		var entityDecl = function(entityName, isParameterEntity, value, base, systemId, publicId, notationName) {
			/* console.log('entityDecl: ' + entityName + ', ' + isParameterEntity + ', ' + value + ', ' + base + ', ' + systemId + ', ' + publicId + ', ' + notationName); */
			that.emit('entityDecl', entityName, isParameterEntity, value, base, systemId, publicId, notationName);
		};

		var error = function(err) { 
			console.log('error');
			that.emit('error', err);
		};

		parser.on('startElement', startElement);
		parser.on('endElement', endElement);
		parser.on('text', text);
		parser.on('processingInstruction', processingInstruction);
		parser.on('comment', comment);
		parser.on('xmlDecl', xmlDecl);
		parser.on('startCdata', startCdata);
		parser.on('endCdata', endCdata);
		parser.on('entityDecl', entityDecl);
		parser.on('error', error);
		parser.parse(buffer, opts.isFinal);

		if(!documentComplete)
			that.emit('error', new Error('XML.parse(): input document is not well-formed XML'));
		
		if(this.opts.c14n)
			this.c14nText = preDocumentC14nText + documentC14nText + postDocumentC14nText;

	};

	Parser.prototype.getC14NText = function() {
		return this.c14nText;
	};

	return Parser;
})();
